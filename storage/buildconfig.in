#! /usr/bin/perl

##  $Id: buildconfig.in 8817 2009-11-17 18:57:19Z iulius $
##
##  Generate linkage code and makefiles for storage and overview methods.
##
##  Goes through all subdirectories of the current directory and finds
##  directories that are either storage methods or overview methods.  Builds
##  methods.[ch] and ovmethods.[ch] as well as makefile stubs.

require 5.003;

use strict;
use vars qw(@OVERVIEW @STORAGE);

# Storage API functions.
@STORAGE = qw(init store retrieve next freearticle cancel ctl flushcacheddata
              printfiles explaintoken shutdown);

# Overview API functions.
@OVERVIEW = qw(open groupstats groupadd groupdel add cancel opensearch search
               closesearch getartinfo expiregroup ctl close);

# Used to make heredocs more readable.
sub unquote { my ($string) = @_; $string =~ s/^:( {0,7}|\t)//gm; $string }

# Parse a method.config file for a storage method, putting information about
# that storage method into the given hash ref.
sub parse_config {
    my ($dir, $file, $config) = @_;
    local $_;
    $$config{sources} ||= [];
    $$config{extra} ||= [];
    $$config{programs} ||= [];
    $$config{makefiles} ||= [];
    open (CONFIG, "$dir/$file") or die "Can't open $dir/$file: $!\n";
    while (<CONFIG>) {
        s/^\s+//;
        s/\s+$//;
        if (/^name\s*=\s*(\S+)$/) {
            my $method = $1;
            die "$dir/$file: $method has already been defined\n"
                if (defined $$config{method}{$method});
            $$config{method}{$method} = $dir;
        } elsif (/^number\s*=\s*(\d+)$/) {
            my $number = $1;
            if (defined $$config{number}{$number}) {
                die "$dir/$file: method number $number was already "
                    . "allocated in $$config{number}{$number}\n";
            }
            $$config{number}{$dir} = $number;
        } elsif (/^sources\s*=\s*(.*)/) {
            my $sources = $1;
            my @sources = split (' ', $sources);
            push (@{ $$config{sources} }, map { "$dir/$_" } @sources);
        } elsif (/^extra-sources\s*=\s*(.*)/) {
            my $extra = $1;
            my @extra = split (' ', $extra);
            push (@{ $$config{extra} }, map { "$dir/$_" } @extra);
        } elsif (/^programs\s*=\s*(.*)/) {
            my $programs = $1;
            my @programs = split (' ', $programs);
            push (@{ $$config{programs} }, map { "$dir/$_" } @programs);
        } else {
            warn "$dir/$file: ignoring unknown line: $_\n";
        }
    }

    # If there is a makefile fragment in the directory, note it.
    if (-f "$dir/method.mk") {
        push (@{ $$config{makefiles} }, "$dir/method.mk");
    } elsif (-f "$dir/ovmethod.mk") {
        push (@{ $$config{makefiles} }, "$dir/ovmethod.mk");
    }
}

# Write out include directives for a list of files.
sub write_includes {
    my ($fh, $config) = @_;
    my $method;
    for $method (sort keys %{ $$config{method} }) {
        my $path = $$config{method}{$method};
        print $fh qq(\#include "$path/$method.h"\n);
    }
}

# Write out the method struct.
sub write_methods {
    my ($fh, $config, $prefix, @funcs) = @_;
    my ($notfirst, $method);
    for $method (sort keys %{ $$config{method} }) {
        print $fh "\n},\n" if $notfirst;
        print $fh qq(\{\n    "$method");
        print $fh ', ', $prefix, '_', uc ($method) if $prefix;
        for (@funcs) {
            print $fh ",\n    ${method}_$_";
        }
        $notfirst++;
    }
    print $fh "\n}\n};\n\n";
}

# Write out the constant defines for methods.
sub write_constants {
    my ($fh, $config, $prefix) = @_;
    my $method;
    for $method (sort keys %{ $$config{method} }) {
        printf $fh "#define ${prefix}_%-30s%d\n", uc ($method),
            $$config{number}{$$config{method}{$method}};
    }
}

# Write out methods.c and methods.h for the interface to the storage
# methods.
sub write_storage {
    my $storage = shift;
    open (DEF, '> methods.c.new') or die "Can't create methods.c.new: $!\n";
    print DEF unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig. */
:
:       #include "interface.h"
:       #include "methods.h"
EOE
    my $method;
    write_includes (\*DEF, $storage);
    print DEF "\nSTORAGE_METHOD storage_methods[",
        scalar (keys %{ $$storage{method} }), "] = {\n";
    write_methods (\*DEF, $storage, 'TOKEN', @STORAGE);
    close DEF;
    rename ('methods.c.new', 'methods.c');

    open (H, '> methods.h.new') or die "Can't open methods.h.new: $!\n";
    print H unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig */
:
:       #ifndef METHODS_H
:       #define METHODS_H 1
:
:       #include "interface.h"
:
EOE
    print H '#define NUM_STORAGE_METHODS ',
        scalar (keys %{ $$storage{method} }), "\n\n";
    write_constants (\*H, $storage, 'TOKEN');
    print H unquote (<<'EOE');
:
:       extern STORAGE_METHOD storage_methods[NUM_STORAGE_METHODS];
:
:       #endif /* METHODS_H */
EOE
    close H;
    rename ('methods.h.new', 'methods.h');
}

# Write out ovmethods.c and ovmethods.h for the interface to the overview
# methods.
sub write_overview {
    my $overview = shift;
    open (DEF, '> ovmethods.c.new')
        or die "Can't create ovmethods.c.new: $!\n";
    print DEF unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig. */
:
:       #include "ovinterface.h"
EOE
    write_includes (\*DEF, $overview);
    print DEF "\nOV_METHOD ov_methods[",
        scalar (keys %{ $$overview{method} }), "] = {\n";
    write_methods (\*DEF, $overview, undef, @OVERVIEW);
    close DEF;
    rename ('ovmethods.c.new', 'ovmethods.c');

    open (H, '> ovmethods.h.new') or die "Can't open ovmethods.h.new: $!\n";
    print H unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig */
:
:       #ifndef OVMETHODS_H
:       #define OVMETHODS_H 1
:
:       #include "ovinterface.h"
:
EOE
    print H '#define NUM_OV_METHODS ',
        scalar (keys %{ $$overview{method} }), "\n";
    print H unquote (<<'EOE');
:
:       extern OV_METHOD ov_methods[NUM_OV_METHODS];
:
:       #endif /* OVMETHODS_H */
EOE
    close H;
    rename ('ovmethods.h.new', 'ovmethods.h');
}

# Return a string setting a makefile variable.  Tab over the = properly and
# wrap to fit our coding standards.
sub makefile_var {
    my ($variable, @values) = @_;
    my $output;
    $output = sprintf ("%-15s =", $variable);
    my $column = 17;
    for (@values) {
        if ($column > 17 && 77 - $column < length ($_)) {
            $output .= " \\\n" . ' ' x 17;
            $column = 17;
        }
        $output .= " $_";
        $column += 1 + length ($_);
    }
    $output .= "\n";
    return $output;
}

# Write out the makefile fragment for overview and storage methods.
sub write_makefile {
    my ($dirs, $sources, $extra, $programs, $makefiles) = @_;
    open (MAKE, '> Make.methods.new')
        or die "Can't create Make.methods.new: $!\n";
    print MAKE "# This file is automatically generated by buildconfig\n\n";
    print MAKE makefile_var ('METHOD_SOURCES', @$sources);
    print MAKE makefile_var ('EXTRA_SOURCES', @$extra);
    print MAKE makefile_var ('PROGRAMS', @$programs);
    for (@$makefiles) {
        print MAKE "\n\n##  Included from $_\n\n";
        open (FRAG, $_) or die "Can't open $_: $!\n";
        print MAKE <FRAG>;
        close FRAG;
    }
    rename ('Make.methods.new', 'Make.methods');
}

my ($dir, %storage, %overview);
if (!-d 'cnfs') {
    if (-d 'storage/cnfs') {
        chdir 'storage' or die "Can't chdir to storage: $!\n";
    } else {
        die "Can't find storage directory (looking for storage/cnfs)\n";
    }
}
opendir (D, ".") or die "Can't open current directory: $!\n";
my @dirs = sort readdir D;
for $dir (@dirs) {
    if (-e "$dir/method.config") {
        parse_config ($dir, 'method.config', \%storage);
    }
    if (-e "$dir/ovmethod.config") {
        parse_config ($dir, 'ovmethod.config', \%overview);
    }
}
write_storage (\%storage);
write_overview (\%overview);
@dirs = (sort values %{ $storage{method} },
         sort values %{ $overview{method} });
my @sources = (sort @{ $storage{sources} }, sort @{ $overview{sources} });
my @extra = (sort @{ $storage{extra} }, sort @{ $overview{extra} });
my @programs = sort (@{ $storage{programs} }, @{ $overview{programs} });
my @makefiles = sort (@{ $storage{makefiles} }, @{ $overview{makefiles} });
write_makefile (\@dirs, \@sources, \@extra, \@programs, \@makefiles);
